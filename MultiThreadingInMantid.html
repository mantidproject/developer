<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Multithreading in Mantid</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head><body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>master</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="index.html">Home</a></li>
                <li><a href="http://download.mantidproject.org">Download</a></li>
                <li><a href="http://www.mantidproject.org">Wiki</a></li>
                <li><a href="http://docs.mantidproject.org">User Documentation</a></li>
                <li><a href="http://www.mantidproject.org/Contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="multithreading-in-mantid">
<h1>Multithreading in Mantid<a class="headerlink" href="#multithreading-in-mantid" title="Permalink to this headline">¶</a></h1>
<div class="section" id="c">
<h2>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<p>Mantid uses <a class="reference external" href="http://openmp.org/wp/about-openmp/">OpenMP</a> in C++ to improve
performance by parallelizing <code class="docutils literal notranslate"><span class="pre">for</span></code> loops. A tutorial devoted to the technology can be found
<a class="reference external" href="https://hpc-tutorials.llnl.gov/openmp/">here</a>.</p>
<p>Access to the OpenMP API is via a set of macros defined in
<a class="reference external" href="https://github.com/mantidproject/mantid/blob/main/Framework/Kernel/inc/MantidKernel/MultiThreaded.h">MultiThreaded.h</a>.
This accomplishes seamless fall-back to single-threaded behaviour for
compilers that don’t have OpenMP available, as well as providing
protection against multithreading when non-thread-safe workspaces are in use.</p>
<p>The recommended way to use OpenMP in an algorithm loop (typically
one over the spectra in a workspace) is as follows:</p>
<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PARALLEL_FOR_IF</span><span class="p">(</span><span class="n">Kernel</span><span class="p">::</span><span class="n">threadSafe</span><span class="p">(</span><span class="o">*</span><span class="n">inputWS</span><span class="p">,</span> <span class="o">*</span><span class="n">outputWS</span><span class="p">))</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numSpec</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">PARALLEL_START_INTERRUPT_REGION</span>

  <span class="o">//</span> <span class="o">....</span> <span class="n">algorithm</span> <span class="n">code</span> <span class="o">....</span>

  <span class="n">PARALLEL_END_INTERRUPT_REGION</span>
<span class="p">}</span>
<span class="n">PARALLEL_CHECK_INTERRUPT_REGION</span>
</pre></div>
</div>
<p>The main work is in the first statement, which contains the
instruction invoking OpenMP, but only if the workspaces given are
thread-safe. Analogous macros are available for zero, 2 or 3 workspaces.
Any workspace that is accessed within the loop should be included.</p>
<p>There is then also a set of slightly verbose interrupt instructions, which
prevent exceptions escaping from a parallel region (which would
otherwise cause program termination) - this includes dealing with
algorithm cancellation.</p>
<p>If you need to use OpenMP in a way that is not covered by any of the specific macros in
<a class="reference external" href="https://github.com/mantidproject/mantid/blob/main/Framework/Kernel/inc/MantidKernel/MultiThreaded.h">MultiThreaded.h</a>
, you can make use of the general purpose <code class="docutils literal notranslate"><span class="pre">PRAGMA_OMP</span></code> macro. This is essentially the same as using <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span></code>
directly. Ideally, this should only be used if what you want to do is not already covered by the other macros.</p>
<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Dynamic</span> <span class="n">scheduling</span> <span class="n">allows</span> <span class="n">x</span> <span class="n">to</span> <span class="n">be</span> <span class="n">split</span> <span class="n">into</span> <span class="n">chunks</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">1</span> <span class="n">processed</span> <span class="n">by</span> <span class="n">each</span> <span class="n">thread</span><span class="p">,</span>
<span class="o">//</span> <span class="n">but</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">threads</span> <span class="ow">in</span> <span class="n">no</span> <span class="n">particular</span> <span class="n">order</span><span class="o">.</span>
<span class="n">PRAGMA_OMP</span><span class="p">(</span><span class="n">parallel</span> <span class="k">for</span> <span class="n">schedule</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">doThing</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: The set of <code class="docutils literal notranslate"><span class="pre">INTERRUPT</span></code> macros can only be used in Mantid algorithms. The rest can be used anywhere.</p>
<div class="section" id="ensuring-thread-safety">
<h3>Ensuring thread-safety<a class="headerlink" href="#ensuring-thread-safety" title="Permalink to this headline">¶</a></h3>
<p>The first rule is this: <strong>Don’t write to shared variables.</strong> Or, if you
do, protect the write with PARALLEL_CRITICAL or PARALLEL_ATOMIC calls.</p>
<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Can</span> <span class="n">only</span> <span class="n">be</span> <span class="n">used</span> <span class="n">on</span> <span class="n">simple</span> <span class="n">operations</span><span class="p">,</span> <span class="n">uses</span> <span class="n">atomic</span> <span class="n">access</span> <span class="kn">from</span> <span class="nn">machine</span> <span class="n">hardware</span><span class="o">.</span>
<span class="n">PARALLEL_ATOMIC</span>
<span class="n">a</span><span class="o">++</span>

<span class="o">//</span> <span class="n">Can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">anywhere</span><span class="p">,</span> <span class="n">but</span> <span class="n">has</span> <span class="n">a</span> <span class="n">higher</span> <span class="n">overhead</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Can</span> <span class="n">be</span> <span class="n">named</span> <span class="k">if</span> <span class="n">two</span> <span class="n">critical</span> <span class="n">sections</span> <span class="n">can</span> <span class="n">be</span> <span class="n">accessed</span> <span class="n">simultaneously</span><span class="o">.</span>
<span class="n">PARALLEL_CRITICAL</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>
<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that a write to a workspace data spectrum selected by the loop
index is not typically a shared write (though see below).</p>
<p>One gotcha comes from the use of copy-on-write pointers to store the
workspace data. Here’s an example:</p>
<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Get</span> <span class="n">references</span> <span class="n">to</span> <span class="n">the</span> <span class="n">x</span> <span class="n">data</span>
<span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">xIn</span> <span class="o">=</span> <span class="n">inputWS</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">auto</span><span class="o">&amp;</span> <span class="n">xOut</span> <span class="o">=</span> <span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">mutableX</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
<p>This can cause problems in the case where the input and output
workspaces are the same. Although the call to <code class="docutils literal notranslate"><span class="pre">outputWS-&gt;mutableX()</span></code> to get a
reference to the output data may look innocuous, in the case where
different spectra are pointing to the same underlying data array this
call will cause the array to be copied, which will invalidate the
reference obtained to the input data in the previous line. The solution
is to make sure the non-const calls come before the const ones (in this
case by reversing the two lines).</p>
</div>
</div>
<div class="section" id="python">
<h2>Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h2>
<p>Tasks in python can be run outside of the main GUI thread by using the classes and functions defined in
<a class="reference external" href="https://github.com/mantidproject/mantid/blob/main/qt/python/mantidqt/mantidqt/utils/asynchronous.py">asynchronous.py</a></p>
<p>The simplest and most commonly used one is <code class="docutils literal notranslate"><span class="pre">AsyncTask</span></code>:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">AsyncTask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_be_run</span><span class="p">,</span> <span class="p">(</span><span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span><span class="p">),</span>
                        <span class="n">error_cb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_worker_error</span><span class="p">,</span>
                        <span class="n">finished_cb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_worker_success</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>For more OpenMP style multithreading, there is the functionality inside
<a class="reference external" href="https://github.com/mantidproject/mantid/blob/main/qt/python/mantidqt/mantidqt/utils/async_qt_adaptor.py">async_qt_adaptor.py</a></p>
<p>The methods you wish to run asynchronously must be inside a class that inherits from <code class="docutils literal notranslate"><span class="pre">IQtAsync</span></code>.
You can then overwrite any of the relevant callbacks and annotate async methods with the <code class="docutils literal notranslate"><span class="pre">&#64;qt_async_task</span></code> decorator.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DoesAsyncThings</span><span class="p">(</span><span class="n">IQtAsync</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finished_cb_slot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_finished</span><span class="p">()</span>

    <span class="nd">@qt_async_task</span>
    <span class="k">def</span> <span class="nf">do_async</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_task</span><span class="p">()</span>
</pre></div>
</div>
<p>Note: These methods are only useful for stopping mantid from hanging while something else is processing.
Due to the nature of the Global Interpreter Lock (GIL), it is not possible to run concurrent threads in python.
For heavy lifting that would require multithreading you should use C++ instead.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>